# FreightOps Pro Backend - Cursor AI Rules
# Powered by Recurse ML methodology for bug detection and code quality

## 🎯 Project Context
This is a production-ready FastAPI backend for a multi-tenant SaaS transportation management system.
Critical focus: Security, multi-tenancy, data integrity, and performance.

## 🔍 Critical Bug Detection Rules

### Multi-Tenancy Data Isolation (CRITICAL)
ALWAYS check for company_id filtering in database queries:
- ❌ REJECT: Any query without .filter(Model.company_id == company_id)
- ❌ REJECT: Direct access to data without tenant verification
- ✅ REQUIRE: Every database query MUST filter by company_id
- ✅ REQUIRE: Verify user belongs to company before any write operation

Example violations to catch:
```python
# BAD - No company_id filter
vehicles = db.query(Vehicle).all()

# GOOD - Proper tenant isolation
vehicles = db.query(Vehicle).filter(Vehicle.company_id == company_id).all()
```

### SQL Injection Prevention
- ❌ REJECT: Raw SQL queries using string formatting or concatenation
- ❌ REJECT: f-strings in SQL queries
- ✅ REQUIRE: Use SQLAlchemy ORM or parameterized queries only
- ✅ REQUIRE: Pydantic validation for all inputs

### Authentication & Authorization
- ❌ REJECT: Endpoints without Depends(get_current_user)
- ❌ REJECT: Plaintext password storage
- ❌ REJECT: JWT secrets in code
- ✅ REQUIRE: All protected endpoints use dependency injection
- ✅ REQUIRE: Bcrypt for password hashing
- ✅ REQUIRE: Environment variables for secrets

### Error Handling
- ❌ REJECT: Bare except clauses (except:)
- ❌ REJECT: Returning stack traces to clients
- ❌ REJECT: Logging sensitive data (passwords, tokens, PII)
- ✅ REQUIRE: Specific exception handling
- ✅ REQUIRE: User-friendly error messages
- ✅ REQUIRE: Detailed logging (without sensitive data)

### Database Operations
- ❌ REJECT: Missing db.commit() after inserts/updates
- ❌ REJECT: Queries without error handling
- ❌ REJECT: N+1 query patterns
- ✅ REQUIRE: Use joinedload() for relationships
- ✅ REQUIRE: Transaction management with try/except
- ✅ REQUIRE: Database indexes on frequently queried fields

### Input Validation
- ❌ REJECT: Accepting user input without Pydantic validation
- ❌ REJECT: Missing field validators
- ❌ REJECT: Trusting client-side validation alone
- ✅ REQUIRE: Pydantic BaseModel for all request bodies
- ✅ REQUIRE: Type hints on all functions
- ✅ REQUIRE: Field validators for complex validation

### API Design
- ❌ REJECT: Endpoints without response models
- ❌ REJECT: Missing status codes
- ❌ REJECT: Returning Model objects directly (use schemas)
- ✅ REQUIRE: response_model on all endpoints
- ✅ REQUIRE: Proper HTTP status codes
- ✅ REQUIRE: Pydantic schemas for responses

### Async/Await Patterns
- ❌ REJECT: Mixing async and sync incorrectly
- ❌ REJECT: Blocking operations in async functions
- ❌ REJECT: Missing await on async calls
- ✅ REQUIRE: Use async def for I/O operations
- ✅ REQUIRE: Await all async function calls
- ✅ REQUIRE: Use async database sessions

### Environment & Configuration
- ❌ REJECT: Hardcoded credentials
- ❌ REJECT: Hardcoded URLs or endpoints
- ❌ REJECT: Missing .env file validation
- ✅ REQUIRE: Environment variables for all config
- ✅ REQUIRE: Pydantic Settings for configuration
- ✅ REQUIRE: Validate required env vars on startup

### Rate Limiting & Security
- ❌ REJECT: Unlimited API requests
- ❌ REJECT: No CORS configuration
- ❌ REJECT: Exposing internal errors to clients
- ✅ REQUIRE: Rate limiting on auth endpoints
- ✅ REQUIRE: Proper CORS settings
- ✅ REQUIRE: Security headers middleware

## 🏗️ Code Quality Standards

### Function Design
- Maximum function length: 50 lines
- Maximum cyclomatic complexity: 10
- Require docstrings for public functions
- Use type hints for all parameters and returns

### Naming Conventions
- snake_case for functions and variables
- PascalCase for classes
- UPPER_CASE for constants
- Descriptive names (no single letters except loop counters)

### Import Organization
1. Standard library imports
2. Third-party imports
3. Local application imports
- Use absolute imports
- One import per line

### Testing Requirements
- Write tests for all business logic
- Test multi-tenant isolation
- Test authentication flows
- Mock external services (Stripe, Gusto, etc.)

## 🚨 Performance Rules

- Use pagination for list endpoints (limit/offset)
- Implement caching for frequently accessed data
- Use select_related/joinedload to prevent N+1 queries
- Monitor query counts per request
- Use background tasks for heavy operations

## 📝 Documentation Rules

- All routes must have docstrings with:
  - Description
  - Parameters
  - Returns
  - Raises
  - Example usage
- Update README.md when adding new features
- Document environment variables in env.example

## 🔄 Migration Rules

- Never modify existing migrations
- Always run "alembic revision --autogenerate"
- Test migrations on development database first
- Include rollback instructions

## 🎯 Before Committing

Run these checks:
1. pytest tests/ (all tests pass)
2. flake8 app/ (no linting errors)
3. black app/ (code formatted)
4. mypy app/ (type checking)
5. No print() statements in code
6. No commented-out code
7. .env not committed

## 🚀 Deployment Checks

- DATABASE_URL configured
- SECRET_KEY is strong and unique
- All migrations applied
- Environment variables validated
- Health check endpoint responds
- HTTPS enforced in production
- Debug mode disabled

## 💡 AI Assistant Instructions

When reviewing or writing code:
1. FIRST check multi-tenant isolation
2. THEN validate security (auth, input validation)
3. THEN check error handling
4. THEN optimize performance
5. FINALLY ensure code quality

If ANY critical rule is violated:
- ⛔ STOP and alert immediately
- 🔍 Explain the security/data risk
- 💡 Provide the correct pattern
- ✅ Wait for confirmation before proceeding

Remember: This is a PRODUCTION system handling real business data. 
Security and data integrity are NOT negotiable.

---

# 🎯 COMPREHENSIVE CODE QUALITY RULES
# Extended Recurse ML Methodology - Full Codebase Analysis

## 1. PERFORMANCE OPTIMIZATION

### Database Performance
- ❌ REJECT: N+1 query patterns (use joinedload)
- ❌ REJECT: Missing pagination on list endpoints
- ❌ REJECT: No query result caching for frequently accessed data
- ✅ REQUIRE: Eager loading with joinedload() for relationships
- ✅ REQUIRE: Redis caching for static/frequent data
- ✅ REQUIRE: Connection pooling properly configured

### Async/Await Performance
- ❌ REJECT: Blocking I/O in async functions
- ❌ REJECT: Sequential async calls that could be parallel
- ✅ REQUIRE: Use asyncio.gather() for parallel operations
- ✅ REQUIRE: Non-blocking external API calls

## 2. CODE COMPLEXITY

### Function Complexity
- ❌ REJECT: Functions >50 lines
- ❌ REJECT: Cyclomatic complexity >10
- ❌ REJECT: Nested if statements >3 levels deep
- ✅ REQUIRE: Extract complex logic into helper functions
- ✅ REQUIRE: Use early returns to reduce nesting

### Code Smells
- ❌ REJECT: God objects/classes
- ❌ REJECT: Long parameter lists (>5 params)
- ❌ REJECT: Mutable default arguments
- ❌ REJECT: Boolean parameters (use enums instead)
- ✅ REQUIRE: Single Responsibility Principle
- ✅ REQUIRE: Parameter objects for >3 params

## 3. CODE DUPLICATION (DRY)

- ❌ REJECT: Copy-pasted code blocks
- ❌ REJECT: Similar endpoint patterns not abstracted
- ❌ REJECT: Repeated validation logic
- ✅ REQUIRE: Reusable utility functions (like tenant_helpers.py)
- ✅ REQUIRE: Shared validation decorators
- ✅ REQUIRE: Extract common patterns

## 4. ARCHITECTURE & DESIGN

### Separation of Concerns
- ❌ REJECT: Business logic in route handlers
- ❌ REJECT: Database queries directly in route handlers
- ❌ REJECT: External API calls in route handlers
- ✅ REQUIRE: Business logic in service layer
- ✅ REQUIRE: Database access through service layer
- ✅ REQUIRE: Adapter pattern for external services

### Imports
- ❌ REJECT: Circular imports
- ❌ REJECT: Import * statements
- ❌ REJECT: Unused imports
- ✅ REQUIRE: Clean import hierarchy
- ✅ REQUIRE: Explicit imports only

## 5. TESTING EXCELLENCE

### Coverage
- ❌ REJECT: No tests for business logic
- ❌ REJECT: <80% test coverage
- ✅ REQUIRE: Tests for all business logic
- ✅ REQUIRE: Integration tests for workflows
- ✅ REQUIRE: Edge case testing

### Quality
- ❌ REJECT: Tests with multiple unrelated assertions
- ❌ REJECT: Slow tests without @pytest.mark.slow
- ✅ REQUIRE: One logical assertion per test
- ✅ REQUIRE: Fast unit tests (<100ms)

## 6. DOCUMENTATION

### Code Documentation
- ❌ REJECT: No docstrings on public functions
- ❌ REJECT: Outdated/misleading comments
- ❌ REJECT: TODO without ticket reference
- ✅ REQUIRE: Docstrings with Args, Returns, Raises
- ✅ REQUIRE: Example usage in complex functions

### API Documentation
- ✅ REQUIRE: All endpoints documented in Swagger
- ✅ REQUIRE: Request/response examples
- ✅ REQUIRE: Error codes documented

## 7. LOGGING & MONITORING

### Logging
- ❌ REJECT: print() statements
- ❌ REJECT: Logging sensitive data
- ❌ REJECT: No correlation IDs
- ✅ REQUIRE: Structured logging with proper levels
- ✅ REQUIRE: Correlation IDs for tracing
- ✅ REQUIRE: Log business events for audit

### Monitoring
- ✅ REQUIRE: Response time metrics
- ✅ REQUIRE: Error rate tracking
- ✅ REQUIRE: Business KPI metrics

## 8. SCALABILITY

### Horizontal Scaling
- ❌ REJECT: In-memory session storage
- ❌ REJECT: File uploads to local disk
- ❌ REJECT: Stateful request handling
- ✅ REQUIRE: Redis for sessions
- ✅ REQUIRE: Cloud storage (S3) for files
- ✅ REQUIRE: Stateless API design

### Database Scalability
- ❌ REJECT: No connection pooling
- ❌ REJECT: Long-running transactions
- ❌ REJECT: Table scans on large tables
- ✅ REQUIRE: Proper connection pool config
- ✅ REQUIRE: Short transactions
- ✅ REQUIRE: Indexes on all filtered/joined columns

## 9. RELIABILITY

### Fault Tolerance
- ❌ REJECT: No timeout on external calls
- ❌ REJECT: No retry logic
- ✅ REQUIRE: Timeouts on all external API calls
- ✅ REQUIRE: Exponential backoff retries
- ✅ REQUIRE: Circuit breakers for failing services

### Data Integrity
- ❌ REJECT: No database constraints
- ❌ REJECT: Race conditions possible
- ✅ REQUIRE: Foreign key constraints
- ✅ REQUIRE: Optimistic locking where needed
- ✅ REQUIRE: Idempotent operations

## 📊 Code Quality Metrics

Track these metrics:
- Cyclomatic complexity: Target <10 per function
- Lines per file: Target <500
- Test coverage: Target >80%
- Documentation coverage: Target 100% public APIs
- API response time: Target p95 <500ms

## 🎯 Comprehensive Review Checklist

For each module:
- [ ] Security: No vulnerabilities
- [ ] Multi-tenancy: All queries filtered
- [ ] Performance: No N+1 queries, proper indexes
- [ ] Error handling: Proper try/except with rollback
- [ ] Validation: Pydantic models for input/output
- [ ] Logging: Structured logging in place
- [ ] Tests: >80% coverage
- [ ] Documentation: All functions documented
- [ ] Complexity: All functions <50 lines, complexity <10
- [ ] Duplication: No copy-pasted code
- [ ] Architecture: Proper separation of concerns
- [ ] Async: Properly used where needed
- [ ] Dependencies: No circular imports, all used
- [ ] Configuration: All from environment variables
- [ ] Scalability: Stateless, horizontally scalable

## 💡 AI Review Instructions

When reviewing ANY code (not just dispatch):

**Level 1 - CRITICAL (Stop if found):**
1. Security vulnerabilities
2. Multi-tenant data leakage
3. Authentication bypasses
4. SQL injection risks

**Level 2 - HIGH (Fix before deploy):**
5. Performance bottlenecks (N+1 queries)
6. Data integrity issues
7. Missing error handling
8. Transaction management issues

**Level 3 - MEDIUM (Fix in sprint):**
9. Code complexity issues
10. Missing tests
11. Poor documentation
12. Code duplication

**Level 4 - LOW (Technical debt):**
13. Code style inconsistencies
14. Minor performance improvements
15. Documentation enhancements

